# 数组和切片

- Go语言的数组在初始化之后就无法更改了，并且存储元素类型相同但是数量不同的数组属于不同类型。
- Go可以直接声明数组大小，也可以通过...声明数组元素数量，但是在运行期间的结果是相同的。Go编译器会在编译期间进行推导运算。并且，Go编译器会在编译期间检查是否越界访问。
- 数组的长度小于4时会放到栈空间，否则就会放到静态只读区。
- 切片维护了一些元数据，是数组的一种包装。切片的复制也是值复制的，但是不会复制底层数组，只是复制元数据。
- 切片的创建分为在静态只读区创建数组和在堆区创建切片的元数据两个部分。在程序启动时，将静态只读区的数据复制到堆区，这样就加快切片的初始化了。
- 如果一个切片使用make()函数分配了超过64KB的空间，那么切片会直接逃逸到堆区。
- 切片会进行内存对齐操作，因此申请的空间不一定是 ``类型大小 * 元素数量`` 。
- 切片可能会在调用append()函数时发生扩容操作，
  - 如果新申请的容量大于旧容量的2倍，那么最终申请的空间就是新申请的。
  - 如果切片的旧长度小于1024，那么最终申请的容量就是旧容量的2倍。否则，开始循环增加1/4的大小。
  - 如果超出了容量计算值的大小，也就是int类型溢出了，最终申请的容量就是新申请的容量。
- copy()函数可以实现切片的深拷贝。

# Map

- Go的Map就是哈希表的实现，哈希表由于找不到完美的Hash()函数导致哈希碰撞，最常用的方法是拉链法和开放寻址法，但是拉链法由于链表的存在很难利用CPU的高速缓存。
- Go语言使用优化的拉链法实现，每一个Bucket都存储了8个元素用于加速访问。
- Go语言允许对值为nil的Map进行访问，但是毫无意义。
- delete关键字用于删除操作，多次执行delete不会报错。
- Map允许的Key类型：
  - 常见的基础数据类型
  - 指针、通道（由相同的make()函数创建的）、空接口。
  - 如果结构体的每个元素都是可比较的，那么结构体就是可比较的。
- Map不支持并发写，只支持并发读。因为Go的设计者认为Map在工程中大概率是一个数据结构的一部分。
- Map的实现是一个hmap结构，hmap包含Bucket，Bucket使用bmap实现，bmap将Key和Value分离存储，这是为了字节对齐压缩空间。
  - 当Bucket中的数据超过8个时，就会将数据存储到Overflow Bucket中，每个bmap都拥有一个overflow指针指向Overflow Bucket。
  - 当Overflow Bucket过多或者超过Map的负载因子大小就会导致Map重建。负载因子=哈希表中的元素数量/Bucket的数量，默认为6.5。
  - Map会扩容到原来的两倍。
- 使用字面量初始化Map最终会在编译期间转换为make操作，字面量个数超过25个时，会构建两个数组专门的存储Key和Value，Runtime循环初始化，否则会在Runtime初始化的时候，直接添加的方式进行赋值。
- Map针对返回值的数量（是否使用ok-idom模式）在编译期将Map访问操作转换为两个不同的函数调用。
- Map在赋值时会修改标志，如果两个赋值操作针对一个数据同时发生，那么就会报错。

# 延迟调用与异常处理

- 函数是Go语言中的一等公民。Go语言支持匿名函数和闭包。普通函数与闭包函数最大的区别在于闭包函数可以引用闭包外的变量。
- 通过配置GOTRACEBACK环境变量，Go语言会生成CoreDump文件，通过gdb或者dlv可以查看。

# 接口与反射

# 调度器

- Go使用CSP的方式实现并发，Erlang使用Actor的方式，两者区别在CSP是Coroutine+Channel，Actor是Coroutine+Message。
- sysmon：是一个特殊的Gourtine，是Go语言提供的用于监测应用程序的线程。这个Goroutine不需要与P关联。其工作内容主要涉及以下几个点：
  - 应用程序创建的Timer：sysmon查看应该在运行却仍处于等待执行时间的计时器，这种情况下，Go将查看空闲的M和P，然后尽可能的快点运行它们。
  - 网络轮询器和系统调用。
  - 垃圾回收：如果垃圾回收线程已经2分钟没有运行，那么sysmon将会强制执行一遍垃圾回收。
  - 长时间运行的Goroutine抢占：任何运行超过10ms的Goroutine都会被抢占，将时间片留给剩下的Goroutine。
- sysmon的运行时机：初始频次为20ns, 如果经过一段时间sysmon没有任何操作，那么将加倍休眠直到10ms。
- GM模型：
  - G是Groutine的缩写，相当于操作系统中的进程控制块。
  - M是一个操作系统线程，所有M是有线程栈的，如果Go不对这个线程提供内存，那么操作系统将会提供。
  - P是一个抽象的概念，等于处理器的逻辑核心数量。由GOMAXPROCS环境变量决定。
  - GM模型存在的问题：
    - 单一的全局互斥锁。
    - Goroutine传递问题：准备就绪的Goroutine经常在M之间传递，导致调度延迟增加和额外的性能开销。
    - M所持有的的缓存数据亲缘性较差，难以利用数据局部性。
    - 严重的线程阻塞和解锁：在syscall的情况下，工作线程M经常被阻塞和取消阻塞。例如M找不到G时，频繁的进入阻塞/唤醒逻辑。
  - 引入P以后，P携带一个本地队列，因为P的存在，runtime不需要做集中式的Goroutine调度，一个M会在与之关联的P的本地队列、全局队列和其他P的本地队列中寻找G执行。
  - P的本地队列由于工作窃取机制的存在，还可能面临着并发访问的问题，因此P的本地队列是无锁的，使用CAS原子操作来完成。
    - ABA问题：使用版本号来实现。
    - 内存一致性：使用内存屏障实现。
    - 原子操作：数据要和总线宽度一致。
- 工作窃取机制：当M在本地队列和全局队列都招不到G时，就会到其他P的本地队列中寻找。由于本地队列的实现是定长的数组（256个G），为了保证公平性，将采取随机化遍历，通过互为质数的步长实现。
  - 工作窃取带来的问题是导致全局队列（使用链表实现）饥饿，因此P在若干轮调度之后会去全局队列寻找G。
  - 新建G时，本地队列全都满了的情况下就会将某个本地队列的前半部分放到全局队列，然后阻塞的syscall也会放到全局队列。
- Go提供了GODEBUG环境变量来观察当前GMP的状态。
- g0栈和g栈：Go的M有系统栈（用于运行runtime的程序逻辑）和g栈（用于运行G的程序逻辑）。在每个M创建的时候会分配一个默认的G叫做g0，g0不执行任何代码逻辑，只是用来存放M的系统栈信息。当要执行Go Runtime的一些逻辑比如创建G或者M的会后，首先要切换到g0栈然后执行，进而执行g任务。
  - M会进入自旋状态：为了提高性能，在两个地方引入了自旋：（1）不带P的M的找P挂载（一有P就会与之关联）和（2）带P的M找G运行（一有准备就绪的G就立即运行）。为了避免过多的浪费资源，自旋的M最多为GOMAXPROCS个，也就是P个。同时有（1）的自旋M存在时，（2）类型的M就不会阻塞。
- 使用syscall时，Go无法限制阻塞的系统线程数量，过多的syscall可能会导致pthread耗尽问题。
- Go 1.14中引入了基于信号的异步抢占调度：注册SIGURG信号，通过sysmon检测，对M对应的线程发送信号，触发注册Handler，它往当前的G的PC寄存器中插入一条指令。在处理完Handler之后，G恢复，自己把自己推到全局队列中。
- GO所有的I/O都是阻塞的，然后通过Groutine+Channel的方式来实现并发。因此G发起网络请求之后也不会导致M阻塞，仅阻塞G，将异步的I/O转换为阻塞I/O的部分称为netpoller。
  - 打开的连接都被netpoller设置为非阻塞模式，然后执行其他G。在文件描述符没有准备好之前，当前G被进入Waiting状态。

# 垃圾回收
