# 数组和切片

- Go语言的数组在初始化之后就无法更改了，并且存储元素类型相同但是数量不同的数组属于不同类型。
- Go可以直接声明数组大小，也可以通过...声明数组元素数量，但是在运行期间的结果是相同的。Go编译器会在编译期间进行推导运算。并且，Go编译器会在编译期间检查是否越界访问。
- 数组的长度小于4时会放到栈空间，否则就会放到静态只读区。
- 切片维护了一些元数据，是数组的一种包装。切片的复制也是值复制的，但是不会复制底层数组，只是复制元数据。
- 切片的创建分为在静态只读区创建数组和在堆区创建切片的元数据两个部分。在程序启动时，将静态只读区的数据复制到堆区，这样就加快切片的初始化了。
- 如果一个切片使用make()函数分配了超过64KB的空间，那么切片会直接逃逸到堆区。
- 切片会进行内存对齐操作，因此申请的空间不一定是 ``类型大小 * 元素数量`` 。
- 切片可能会在调用append()函数时发生扩容操作，
  - 如果新申请的容量大于旧容量的2倍，那么最终申请的空间就是新申请的。
  - 如果切片的旧长度小于1024，那么最终申请的容量就是旧容量的2倍。否则，开始循环增加1/4的大小。
  - 如果超出了容量计算值的大小，也就是int类型溢出了，最终申请的容量就是新申请的容量。
- copy()函数可以实现切片的深拷贝。

# Map

- Go的Map就是哈希表的实现，哈希表由于找不到完美的Hash()函数导致哈希碰撞，最常用的方法是拉链法和开放寻址法，但是拉链法由于链表的存在很难利用CPU的高速缓存。
- Go语言使用优化的拉链法实现，每一个Bucket都存储了8个元素用于加速访问。
- Go语言允许对值为nil的Map进行访问，但是毫无意义。
- delete关键字用于删除操作，多次执行delete不会报错。
- Map允许的Key类型：
  - 常见的基础数据类型
  - 指针、通道（由相同的make()函数创建的）、空接口。
  - 如果结构体的每个元素都是可比较的，那么结构体就是可比较的。
- Map不支持并发写，只支持并发读。因为Go的设计者认为Map在工程中大概率是一个数据结构的一部分。
- Map的实现是一个hmap结构，hmap包含Bucket，Bucket使用bmap实现，bmap将Key和Value分离存储，这是为了字节对齐压缩空间。
  - 当Bucket中的数据超过8个时，就会将数据存储到Overflow Bucket中，每个bmap都拥有一个overflow指针指向Overflow Bucket。
  - 当Overflow Bucket过多或者超过Map的负载因子大小就会导致Map重建。负载因子=哈希表中的元素数量/Bucket的数量，默认为6.5。
  - Map会扩容到原来的两倍。
- 使用字面量初始化Map最终会在编译期间转换为make操作，字面量个数超过25个时，会构建两个数组专门的存储Key和Value，Runtime循环初始化，否则会在Runtime初始化的时候，直接添加的方式进行赋值。
- Map针对返回值的数量（是否使用ok-idom模式）在编译期将Map访问操作转换为两个不同的函数调用。
- Map在赋值时会修改标志，如果两个赋值操作针对一个数据同时发生，那么就会报错。

# 延迟调用与异常处理

- 函数是Go语言中的一等公民。Go语言支持匿名函数和闭包。普通函数与闭包函数最大的区别在于闭包函数可以引用闭包外的变量。
- 通过配置GOTRACEBACK环境变量，Go语言会生成CoreDump文件，通过gdb或者dlv可以查看。

# 接口与反射

# 调度器

- Go使用CSP的方式实现并发，Erlang使用Actor的方式，两者区别在CSP是Coroutine+Channel，Actor是Coroutine+Message。
- sysmon：是一个特殊的Gourtine，是Go语言提供的用于监测应用程序的线程。这个Goroutine不需要与P关联。其工作内容主要涉及以下几个点：
  - 应用程序创建的Timer：sysmon查看应该在运行却仍处于等待执行时间的计时器，这种情况下，Go将查看空闲的M和P，然后尽可能的快点运行它们。
  - 网络轮询器和系统调用。
  - 垃圾回收：如果垃圾回收线程已经2分钟没有运行，那么sysmon将会强制执行一遍垃圾回收。
  - 长时间运行的Goroutine抢占：任何运行超过10ms的Goroutine都会被抢占，将时间片留给剩下的Goroutine。
- sysmon的运行时机：初始频次为20ns, 如果经过一段时间sysmon没有任何操作，那么将加倍休眠直到10ms。
- GM模型：
  - G是Groutine的缩写，相当于操作系统中的进程控制块。
  - M是一个操作系统线程，所有M是有线程栈的，如果Go不对这个线程提供内存，那么操作系统将会提供。
  - P是一个抽象的概念，等于处理器的逻辑核心数量。由GOMAXPROCS环境变量决定。
  - GM模型存在的问题：
    - 单一的全局互斥锁。
    - Goroutine传递问题：准备就绪的Goroutine经常在M之间传递，导致调度延迟增加和额外的性能开销。
    - M所持有的的缓存数据亲缘性较差，难以利用数据局部性。
    - 严重的线程阻塞和解锁：在syscall的情况下，工作线程M经常被阻塞和取消阻塞。例如M找不到G时，频繁的进入阻塞/唤醒逻辑。
  - 引入P以后，P携带一个本地队列，因为P的存在，runtime不需要做集中式的Goroutine调度，一个M会在与之关联的P的本地队列、全局队列和其他P的本地队列中寻找G执行。
  - P的本地队列由于工作窃取机制的存在，还可能面临着并发访问的问题，因此P的本地队列是无锁的，使用CAS原子操作来完成。
    - ABA问题：使用版本号来实现。
    - 内存一致性：使用内存屏障实现。
    - 原子操作：数据要和总线宽度一致。
- 工作窃取机制：当M在本地队列和全局队列都招不到G时，就会到其他P的本地队列中寻找。由于本地队列的实现是定长的数组（256个G），为了保证公平性，将采取随机化遍历，通过互为质数的步长实现。
  - 工作窃取带来的问题是导致全局队列（使用链表实现）饥饿，因此P在若干轮调度之后会去全局队列寻找G。
  - 新建G时，本地队列全都满了的情况下就会将某个本地队列的前半部分放到全局队列，然后阻塞的syscall也会放到全局队列。
- Go提供了GODEBUG环境变量来观察当前GMP的状态。
- g0栈和g栈：Go的M有系统栈（用于运行runtime的程序逻辑）和g栈（用于运行G的程序逻辑）。在每个M创建的时候会分配一个默认的G叫做g0，g0不执行任何代码逻辑，只是用来存放M的系统栈信息。当要执行Go Runtime的一些逻辑比如创建G或者M的会后，首先要切换到g0栈然后执行，进而执行g任务。
  - M会进入自旋状态：为了提高性能，在两个地方引入了自旋：（1）不带P的M的找P挂载（一有P就会与之关联）和（2）带P的M找G运行（一有准备就绪的G就立即运行）。为了避免过多的浪费资源，自旋的M最多为GOMAXPROCS个，也就是P个。同时有（1）的自旋M存在时，（2）类型的M就不会阻塞。
- 使用syscall时，Go无法限制阻塞的系统线程数量，过多的syscall可能会导致pthread耗尽问题。
- Go 1.14中引入了基于信号的异步抢占调度：注册SIGURG信号，通过sysmon检测，对M对应的线程发送信号，触发注册Handler，它往当前的G的PC寄存器中插入一条指令。在处理完Handler之后，G恢复，自己把自己推到全局队列中。
- GO所有的I/O都是阻塞的，然后通过Groutine+Channel的方式来实现并发。因此G发起网络请求之后也不会导致M阻塞，仅阻塞G，将异步的I/O转换为阻塞I/O的部分称为netpoller。
  - 打开的连接都被netpoller设置为非阻塞模式，然后执行其他G。在文件描述符没有准备好之前，当前G被进入Waiting状态。
- 在使用Channel通信的Goroutine会导致频繁的阻塞，G会不断的在本地队列中排队，Go语言针对communicate-and-wait模式进行了亲缘性调度的优化，Go在1.5引入了P.runnext字段，可以高优先级执行一个解锁的G。
- Go程序的启动：Go程序启动以后会运行一段ASM代码，然后在runtime_rt0.go中执行一堆初始化工作，接下来创建m0和g0，m0就是主线程，g0负责调度。m0和g0通过p0进行绑定，然后创建GOMAXPROCS个P进行缓存。接下来在执行runtime.main()函数启动sysmon线程和GC线程。
- g0基于两种断点将G调度的线程上：（1）当G阻塞的时候，syscall、mutex或者channel。（2）函数调用期间如果G必须扩展其堆栈，避免M空耗扩展堆栈的时间。
- 释放G：当G运行完成以后不会直接释放，而是放到P维护的空闲链表中。调度器也维护了两个空闲链表，用来存放有栈的G和无栈的G。当本地空闲链表超过64时，就会将一半的G移动到调度器空闲链表中。当G的栈超过2KB时，栈将会被销毁，变成无栈的空闲G。

# 内存分配

- 分段栈：初始大小为2KB，比x86_64架构下的2MB小很多，Goroutine在运行过程中会按照需求进行增长和伸缩，占用的内存最大限制的默认值在64位系统上是1GB。
  - 存在热分裂问题：如果栈快满了，那么下一次函数调用会强制触发栈扩容，当函数返回时，一部分栈空间被清理掉，如果这个分配栈的操作在一个循环中，那么将会产生严重的性能下降。
  - Go在1.2版本不得不把栈大小调整为8KB，但是只是降低了热分裂问题，直到实现了连续栈才真正解决。
- 连续栈：采用复制栈空间的方式实现，直接分配一个两倍大的空间，然后将数据复制到新空间，当栈缩容时什么也不做。如果使用率不足1/4，那么下一次GC后同样使用复制栈的方式进行缩容。
  - runtime会在调用函数中插入runtime.morestack()函数，但是每个函数都调用计算判断是否需要扩容，那么成本就很高。Go会在编译期计算SP寄存器、函数栈帧大小确定哪个函数需要插入。
- Go的内存分配参考了TCmalloc的设计，采用分层方式。
  - 内存碎片：随着内存的不断申请和释放，内存上的碎片会通过合并的方式减少。
  - 大锁：同一个进程下的所有线程共享内存空间，申请内存时需要加锁。
- 当发生小于32KB的内存申请时，Go会从mcache的本地缓存里分配，单位是mspan。每个P会绑定mcache，因此不需要加锁。
- mspan由多个page构成，page是一8KB的内存空间，Go与操作系统之间的申请和释放都是以page为单位的。一个mspan在初始化时会被切分为多个相同大小的object。每个内存页分为多个固定大小的空间，有助于减少内存碎片，在Linux内核和memcache的SLAB分配器中都有体现。
- mcache中不存在空闲mspan后，Go会为每个类别（8KB-32KB）的mspan维护一个mcentral，mcentral为所有的mcache提供切分好的mspan。每个mcentral对应一种mspan，并且分为空闲链表和非空闲链表。

# 垃圾回收
