# 数组和切片

- Go语言的数组在初始化之后就无法更改了，并且存储元素类型相同但是数量不同的数组属于不同类型。
- Go可以直接声明数组大小，也可以通过...声明数组元素数量，但是在运行期间的结果是相同的。Go编译器会在编译期间进行推导运算。并且，Go编译器会在编译期间检查是否越界访问。
- 数组的长度小于4时会放到栈空间，否则就会放到静态只读区。
- 切片维护了一些元数据，是数组的一种包装。切片的复制也是值复制的，但是不会复制底层数组，只是复制元数据。
- 切片的创建分为在静态只读区创建数组和在堆区创建切片的元数据两个部分。在程序启动时，将静态只读区的数据复制到堆区，这样就加快切片的初始化了。
- 如果一个切片使用make()函数分配了超过64KB的空间，那么切片会直接逃逸到堆区。
- 切片会进行内存对齐操作，因此申请的空间不一定是 ``类型大小 * 元素数量`` 。
- 切片可能会在调用append()函数时发生扩容操作，
  - 如果新申请的容量大于旧容量的2倍，那么最终申请的空间就是新申请的。
  - 如果切片的旧长度小于1024，那么最终申请的容量就是旧容量的2倍。否则，开始循环增加1/4的大小。
  - 如果超出了容量计算值的大小，也就是int类型溢出了，最终申请的容量就是新申请的容量。
- copy()函数可以实现切片的深拷贝。

# Map

- Go的Map就是哈希表的实现，哈希表由于找不到完美的Hash()函数导致哈希碰撞，最常用的方法是拉链法和开放寻址法，但是拉链法由于链表的存在很难利用CPU的高速缓存。
- Go语言使用优化的拉链法实现，每一个Bucket都存储了8个元素用于加速访问。
- Go语言允许对值为nil的Map进行访问，但是毫无意义。
- delete关键字用于删除操作，多次执行delete不会报错。
- Map允许的Key类型：
  - 常见的基础数据类型
  - 指针、通道（由相同的make()函数创建的）、空接口。
  - 如果结构体的每个元素都是可比较的，那么结构体就是可比较的。
- Map不支持并发写，只支持并发读。因为Go的设计者认为Map在工程中大概率是一个数据结构的一部分。
- Map的实现是一个hmap结构，hmap包含Bucket，Bucket使用bmap实现，bmap将Key和Value分离存储，这是为了字节对齐压缩空间。
  - 当Bucket中的数据超过8个时，就会将数据存储到Overflow Bucket中，每个bmap都拥有一个overflow指针指向Overflow Bucket。
  - 当Overflow Bucket过多或者超过Map的负载因子大小就会导致Map重建。负载因子=哈希表中的元素数量/Bucket的数量，默认为6.5。
  - Map会扩容到原来的两倍。
- 使用字面量初始化Map最终会在编译期间转换为make操作，字面量个数超过25个时，会构建两个数组专门的存储Key和Value，Runtime循环初始化，否则会在Runtime初始化的时候，直接添加的方式进行赋值。
- Map针对返回值的数量（是否使用ok-idom模式）在编译期将Map访问操作转换为两个不同的函数调用。
- Map在赋值时会修改标志，如果两个赋值操作针对一个数据同时发生，那么就会报错。

# 延迟调用与异常处理

- 函数是Go语言中的一等公民。Go语言支持匿名函数和闭包。普通函数与闭包函数最大的区别在于闭包函数可以引用闭包外的变量。
- 通过配置GOTRACEBACK环境变量，Go语言会生成CoreDump文件，通过gdb或者dlv可以查看。

# 接口与反射

# 调度器

- sysmon：是一个特殊的Gourtine，是Go语言提供的用于监测应用程序的线程。这个Goroutine不需要与P关联。其工作内容主要涉及以下几个点：
  - 应用程序创建的Timer：sysmon查看应该在运行却仍处于等待执行时间的计时器，这种情况下，Go将查看空闲的M和P，然后尽可能的快点运行它们。
  - 网络轮询器和系统调用。
  - 垃圾回收：如果垃圾回收线程已经2分钟没有运行，那么sysmon将会强制执行一遍垃圾回收。
  - 长时间运行的Goroutine抢占：任何运行超过10ms的Goroutine都会被抢占，将时间片留给剩下的Goroutine。
- sysmon的运行时机：初始频次为20ns, 如果经过一段时间sysmon没有任何操作，那么将加倍休眠直到10ms。
- GM模型：
  - G是Groutine的缩写，相当于操作系统中的进程控制块。
  - M是一个操作系统线程，所有M是由线程栈的，如果Go不对这个线程提供内存，那么操作系统将会提供。
  - P是一个抽象的概念，等于处理器的逻辑核心数量。由GOMAXPROCS环境变量决定。
- Go提供了GODEBUG环境变量来观察当前GMP的状态。
- g0栈和g栈：Go的M有系统栈（用于运行runtime的程序逻辑）和g栈（用于运行G的程序逻辑）。在每个M创建的时候会分配一个默认的G叫做g0，g0不执行任何代码逻辑，只是用来存放M的系统栈信息。当要执行Go Runtime的一些逻辑比如创建G或者M的会后，首先要切换到g0栈然后执行，进而执行g任务。

# 垃圾回收