# 知识来源

- CMU 15-445/645 数据库系统导论
- MySQL技术内幕InnoDB存储引擎
- 数据库系统概念

# 数据库的基本抽象

数据库系统的构建可以从上到下分为5个层次：

- 查询计划
- 算子执行
- 访问方法
- 缓冲池管理
- 存储管理

CMU的数据库导论课程根据从下到上的顺序构建。

# 存储管理

计算机系统的存储架构按照速度可以进行排序：

- CPU寄存器
- CPU缓存
- 动态内存
- 固态硬盘
- 机械磁盘
- 网络存储

CPU寄存器和CPU缓存是CMU 15-721的主要内容。数据库系统的存储引擎就是存储管理系统。

> 主要知识：

- 数据库中的数据落实到磁盘上，可能是像SQLlite一样的**单文件**，也可能是像PostgreSQL一样的**多文件**；并且有的数据库系统可能会自研文件系统，但是现代数据库通常不会，因为这样很难被部署到云厂商的服务器上。

- 数据库通常使用“页”这种概念来描述数据块，并且数据库要求数据是“自托管的”，也就是说元数据和数据都应该被管理。每个数据页都会有一个全局唯一的PageID。

- **数据库的元数据存储方式**：有的数据库的元数据会被单独存储到一个页，数据存储到其他的页，而有的数据库数据和元数据会存储到同一个页（独立的页，self-contained page），因此这有利于**灾备**，例如Oracle。

- **操作系统的mmap可能对于数据库系统来说是灾难**，例如MongoDB的第一版本使用了mmap，研发上做了很多无用功。

- **Indirection 层**用于实现数据页映射到某个集合中一个文件的具体位置。PageID可以是数据页在对应文件的相对位置，那么知道整体文件的初始位置和数据页大小就可以知道具体的Offset值。
    - 优点：如果整体移动数据文件，例如更换硬盘，那么PageID就可以保持不变了。

- 页的三种概念：
    - 硬件的页： 硬件存储暴露的组织数据存储的概念，并且是**原子读写**的数据块大小，**通常是4KB**。
        - 例如16KB，可能前8KB数据写入了，由于异常，剩余的8KB也写入了，但是不连续，导致是损坏的数据。
    - 操作系统的页：从存储设备上取出数据放到内存中的表示，**通常是4KB**。
    - 数据库系统的页：通常是512B - 16KB。

- 在存储引擎级别，我们不关心数据页中到底有什么：
    - **堆文件，无序且随机**。构建这种文件的方式：
        - 数据页头（页的元数据区）中有**两个指针**，指向Free页链表和Data页链表。
        - 使用**Directory**的概念包装数据页，这个Directory中包含Free页和Data页。
    - 顺序/排序文件
    - 哈希文件

- 数据页大小是固定的，并且要比操作系统和硬件的页更大一些。
    - 如果数据页较小，那么一个PageID所表达的数据范围更小，**页表就会导致膨胀**，那么就可能会产生缓存丢失，**类似于TLB**。

- 由于数据库的页一般要比操作系统和硬件存储的页大，那么就出现了一个数据库的页使用随机还是连续的方式落实到下游的页；并且多个下游的数据页如何安全的原子的保存，这样写入数据的代价就会变高，因此商用数据库**允许应用进行调整**。
    - 对页的灾备可以使用日志的方式实现。

- 在数据页中存储元组，也就是数据库行记录，那么，可以采用顺序存储，但是存在的问题是删除元组会**存储空洞**，因此一个可行的方案是**Slotted Pages**，本质是在数据页头区域设置一个**Slot Array**，用来记录元组的偏移量。
    - Slotted Pages方案**无法解决变长元组带来的空间损失**，因此PostgreSQL提供了**Vaccum操作**用于处理这些空间。类似于GC（垃圾回收）。

- 元组的布局方式也分为数据区和元数据区。元组中的数据无论是否对齐，数据都会连续存储，这种模型叫做**N-ARY模型**。元组的DML速度很快，但是对于TB级别的数据分析通常只需要几列而不是整个元组读出，因此OLAP数据库中有列式存储。

- 另一种存储方式是采用**结构化日志**存储数据而不是页。
    - 优点是便于**回滚**且便于操作。
    - 缺点是很**难读**，因为追加的是DML语句，也可以经过优化，然后存储被一个DML修改后的数据。

- 如果不想丢失数据的精度，就需要使用**固定的浮点**表示数，但是这需要数据库系统去实现。

- 对于大型的二进制数据，可能的方式是**Overflow Page**或者**外部文件**。
    - 对于移动应用来说，将文件存储到数据库效率更高，因为不需要获取文件描述符等其他指针。

# 缓冲池管理

缓冲池用于存储磁盘加载到内存的数据，但是存储单位是**Frame**；Frame对应磁盘上Slot的概念而不是页。

> 主要知识：

- 数据库系统必须通过一个**Page Table**（实质上是哈希表结构）来维护Frame和Page的关系。Page Table和Page Directory的区别：
    - Page Table是内存中的结构，维护缓冲池与Page ID的映射关系；需要确保是线程安全的。
    - Page Directory是数据库文件的存储结构。

- 数据库系统通常维护一些元数据，例如：
    - Dirty Flag 用于表示缓冲池中的数据是否被修改过。
    - Pin/Ref Count 用于表示占用该Page的线程数量。

- Lock和Latch的区别:
    - Lock是数据库系统的逻辑原语，用于保护数据库的逻辑内容。
    - Latch是一种底层保护原语，用于保护数据库系统物理结构的关键部分（数据结构或者内存中的数据），Latch一般会使用自旋锁。
    - Lock的对象是**事务**，Latch的对象是**线程**。所以Lock保护的对象是**数据库数据**，而Latch是**内存中的数据结构**。
    - Lock发生在整个事务过程中，而Latch是产生临界资源的时候。
    - Lock主要的实现是行锁，表锁，意向锁；Latch的主要实现是操作系统级别的**读写锁和互斥量**。
    - Lock的死锁检测手段一般是**等待图，依赖图或者超时机制**，Latch一般不存在死锁检测和处理机制，只是通过应用程序加锁顺序保证没有死锁的情况发生。
    - 因此Lock被**锁管理器（可以实现为一个进程，从事务接收消息并反馈）**的哈希表锁容纳，Latch则在数据库系统实现的代码中。

- 如何为缓冲池分配足够的内存空间?
    - 全局策略：针对整个系统来考虑，所做出的的解决会使得整个系统受益。
    - 局部策略：针对每个查询或者事务来考虑，但是对于整个系统可能是糟糕的。

- 多缓冲池、预读取、扫描共享、缓冲池旁路：
    - 数据库可以存在多个缓冲池，每个缓冲池都有自己的Page Table维护一套Page ID到Frame的映射。这样做是为了**可以在每个缓冲池上使用局部策略并且减少Latch争用的出现**。
        - ObjectID：使用 (ObjectID, PageID, SlotNum) 三元组来确定加载哪些数据。这样可以通过ObjectID查询到数据。
        - 哈希表：通过Hash确定缓冲池中的位置，通过取模确定在哪个缓冲池里。、
    - **预读取用于减少查询线程的停顿**，从而达到**减少最小化随机IO**。本质是预测SQL的查询范围和动作意图。
    - **扫描共享用于将一份数据尽可能多的用于多个查询线程**，这不等同于结果缓存。实现上是将多个查询线程附加到当前的**游标**数据结构中。
        - 当不同的线程计算相同的数据，那么这些数据可以横跨多个线程共享它们需要的结果，这叫做**物化视图**。
        - 完整的方案只有DB2和SQL Server支持，Oracle支持的基本扫描共享技术叫做**游标共享技术**，两个线程在同时执行时才会有效。
    - **缓冲池旁路是从本地内存中查找一部分想要的数据并且不污染缓冲池的缓存规律**，有的系统也叫做Buffer Cache旁路。执行查询时从磁盘将数据**加载到本地内存而不是缓冲池**，因为查询缓冲池需要Latch，存在一定的代价，但是这样做只能是**中间结果和扫描量比较小**的时候用。
        - 许多数据库系统使用Direct IO跳过操作系统页缓存（操作系统维护的文件系统缓存）。
        - 唯一利用操作系统页缓存的是PostgreSQL，并且为每个线程维护一个很小的缓冲池, 因为设计者从工程师的角度去考虑，但是会降低性能。
            - PostgreSQL提供了pg_prewarm扩展程序实现当用户调用这个函数的时候就会将表的所有数据页放到缓冲池。
            - 某些数据库系统不喜欢操作系统页缓存是由于**跨平台特性导致不同系统的策略不同，丧失一致性**。
        - MySQL和Oracle会用所有的系统内存。
        - 通过将 ``/proc/sys/vm/drop_caches`` 就可以强制让操作系统将操作系统页缓存持久化到磁盘。

- 缓冲池替换策略
    - LRU：实现方式是跟踪Page的访问时间戳。
        - LRU-K: 只有最近被访问K次的才可以在缓冲池中。
    - Clock, 与LRU类似
        - 解决了LRU需要跟踪每个Page的访问时间戳的问题，但是需要维护每个Page的标志位。
        - 需要将Page设置到**环形的缓冲池**，有一个旋转的指针来检查哪些Page需要移除。
        - 不会精确的移除最近最少使用的Page。

# 读写方法

