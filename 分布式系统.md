# 知识来源

- MIT 6.824 分布式系统
- DDIA

# GFS

# Raft

Quorum: 奇数个副本，那么就会在故障时产生不对等，那么就可以选出大多数了。2f+1个副本能够容忍f个机器故障。

Raft以库的形式包含在应用程序代码中，副本服务的构建通过包含Raft库并加入RPC的调用实现通信。MIT的课程中举例是保护分布式键值存储服务器。服务器的构建分为两层，键值存储层和Raft层，为了正确的使用Raft层保存这些状态，通常需要构建键值存储层的操作日志，然后由Raft层保证这些日志的合理性。这个分布式的键值存储服务器不希望客户端能够意识到与它通信的是一组副本而不是单个服务器。

Client将请求发送到副本的Leader中，Raft会与其他的副本通信，直到大多数副本同意同意日志记录并完成。Raft层向键值存储层发出通知，键值存储层就可以提交这个操作了。

Raft的通信消息并不是立刻发出的，而是通过心跳消息或者其他消息打包发出，这样就避免了频繁的消息，但是这会导致客户端延时增加，因此Raft通常会设计超时机制。

日志对于Leader的用途在于保存Leader所做的操作，并且在Follower故障以后重新发送漏掉的日志。

日志还会在机器发生故障后恢复数据发挥作用。

Leader与Follower的关系类似于生产者消费者模型，Leader的处理速度高于Follower时，无限制的存储会引发内容的溢出。Raft无法应对。

# Zookeeper

# Spanner

Google过去使用MySQL和BigTable提供Web和广告服务，维护这些数据的分片很耗时，并且很需要强一致性。之前的广告系统不支持使用事务，Spanner想要解决的问题是全球的强一致性数据库系统，这个系统使用了两个巧妙的思想：

- 使用Paxos解决2PC事务协调器的容错问题。
- 使用同步时间实现了高效的只读事务。

Google提供了Spanner的云服务。Spanner主要用于只读事务，因为Google的广告业务只读事务超过十亿，而读写事务只有几百万。

## 架构

不同的数据中心通过机器部署这Spanner服务，然后每个数据中心都维护了数据的副本，相同数据的副本一致性构成了Paxos组，使用Paxos维护数据的一致性。数据中心的机器也部署了Spanner的客户端，用来读取本地机器的数据。

## 读写事务

当一个事务修改X和读取Y数据时，Spanner会在这两个数据所在的Paxos选出Leader，并且在这些Leader中选出一个作为事务协调器。并将写请求发送给Leader，Leader向所在的Paxos组的其他机器发送准备消息，然后Leader告诉事务协调器可以接收写入，事务协调器就会提交这个事务。多个Leader中的其他Leader作为备选的事务协调器，实现了高效与灾备。

Spanner使用完全标准的两阶段锁保证了事务的有序性，并且使用两阶段提交来保证事务的分布式能力。Spanner通过Paxos算法消除了两阶段提交的Leader崩溃问题，同时也解决了事务协调器持有两阶段锁发生故障导致阻塞的问题。

上面的实现存在的问题是整个拓扑存在大量的消息，这些消息跨域具备不同地理位置的数据中心，因为这些单节点上运行数纳秒的计算在Spanner变成毫秒，甚至秒。

## 只读事务

只读事务不会导致消息过多问题，Spanner消除了读写事务中的两个巨大成本的问题：

- 只读事务可以从本地读取数据，跨国读取数据可能需要更高的延迟，本地读取可能不是最新的数据。
- 没有使用2PL和2PC，并且没有使用事务管理器，这避免了联系Paxos组。

Spanner具备快照隔离级别，因为读写事务会对只读事务造成影响，Spanner为每个事务分配时间戳：

- 读写事务的时间戳是事务提交的时间。
- 只读事务的时间戳是事务执行的时间。
